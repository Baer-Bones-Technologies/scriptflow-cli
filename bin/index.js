#!/usr/bin/env node


import boxen from 'boxen';
import chalk from 'chalk';
import childProcess from 'child_process';
import fs from 'fs/promises';
import inquirer from 'inquirer';
import os from 'os';
import packageJson from '../package.json' assert { type: "json" };
import path from 'path';
import util from 'util';
import yargs from 'yargs/yargs';

import {fileURLToPath} from 'url';
import { hideBin }  from 'yargs/helpers';

// tool used for stylization of the console output
const prettify = {
/** 
* @function formatError
* @function formatSuccess
* @function fotmatAnnouncement
* @function formatLink
* @function formatInfo
  */
  formatError(message) {
    return chalk.red(message);
  },
  formatSuccess(message) {
    return chalk.green(message);
  },
  formatAnnouncement(message) {
    const boxenOptions = {
      padding: 1,
      margin: 1,
      borderStyle: 'round',
      borderColor: 'yellow',
      backgroundColor: 'black'
    };
    return boxen(chalk.yellow(message), boxenOptions);
  },
  formatLink(message) {
    return chalk.blue.underline(message);
  },
  formatInfo(message) {
    return chalk.blue(message);
  }

} 

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const configFile = path.join(__dirname, "config.json") 
const executeCommand = util.promisify(childProcess.exec);


/**
 * Function that formats announcements for a specific version
 * @param {String} versionChoice the chosen version to view announcements for 
 * @returns 
 */
const announcements = async ({ versionChoice = packageJson.version }) => {
  try{
  const config = await loadConfig();

  if(versionChoice === "LIST"){
    return announcementVersionList();
  }
  
  console.log(prettify.formatInfo("Loading announcements for version: " + versionChoice))
  for (var i = 0; i < config.announcements.length; i++) {
    if (config.announcements[i].version === versionChoice || versionChoice === "ALL") {
      var announcementOutput = "Announcements for version: " + config.announcements[i].version + "\n";
      for(const message in config.announcements[i].messages){
        announcementOutput += "    - " + config.announcements[i].messages[message] + "\n";
      }
      console.log(prettify.formatAnnouncement(announcementOutput));
    }
  }
} catch (error) {
  console.error(prettify.formatError("Error loading announcements:"), error.message);
}
}

/**
 * Function that asks user which version of the announcements they would like to view
 */
const announcementVersionList = async () => {
  const config = await loadConfig();

  await checkInit();

  const versionList = config.announcements.map((announcement) => {
    return announcement.version;
  });
  versionList.push("ALL");

  const versionAnswer = await inquirer.prompt({
    type: "list",
    name: "version",
    message: "Select a version to view announcements for:",
    choices: versionList,
  }); 
  await announcements({ versionChoice: versionAnswer.version });
}

const checkInit = async () => {
  const config = await loadConfig();
  if (!config.initialized) {
    prettify.formatError(console.log(
      'Flow manager is not initialized. Please run "flow init" to initialize it.'
    ));
    return false;
  }
  return true;
}
/**
 * Function that checks for updates to the scriptflow-cli
 **/
const checkForUpdates = async () => {
  const { stdout, stderr } = await executeCommand(
    "npm view scriptflow-cli version"
  );
  const latestVersion = stdout.trim();

  if (compareVersions({latestVersion:latestVersion}) === true) {
    console.log(
      'A new version of scriptflow-cli is available.\nRun "flow update" to update flows and cli to latest version\nor\n"npm i -g scriptflow-cli" to update only the CLI.'
    );
  }
};

/**
 * Function that checks the script for the current version
 * @param {String} scriptFile Path to the script file
 * @returns {Boolean} True if the script needs to be updated, otherwise false
 */
const checkScriptForVersion = async (scriptFile) => {
  const currentVersion = packageJson.version;
  const scriptContent = await fs.readFile(scriptFile, "utf-8");
  if (!scriptContent.includes("scriptflow-cli " + currentVersion)) {
    const prompt = await inquirer.prompt({
      type: "confirm",
      name: "update",
      message:
        prettify.formatAnnouncement("This script was generated by an older version of scriptflow-cli, and possibly wont display command output. Would you like to update your flow?"),
      default: true,
    });
    return prompt.update;
  }
};

/**
 * Function that clears all flows
 */
const clear = async () => {
  //remove all flows
  const flows = await loadFlows();
  for (const flow of flows) {
    console.log("Deleting flow: " + flow.name);
    deleteFlow(flow.name);
  }
};

/**
 * Function that breaks down and compares the latest version with the current version between major, mid, and minor versions
 * @param {String}latestVersion latest Version available 
 * @returns 
 */
const compareVersions = ({latestVersion = packageJson.version}) => {
  var needsUpdate = false;
  if (latestVersion !== packageJson.version) {
    const tempLatestVersion = latestVersion.split(".");
    const tempCurrentVersion = packageJson.version.split(".");
    if (tempLatestVersion[0] > tempCurrentVersion[0]) {
      needsUpdate = true;
    } else if (tempLatestVersion[1] > tempCurrentVersion[1]) {
      needsUpdate = true;
    } else if (tempLatestVersion[2] > tempCurrentVersion[2]) {
      needsUpdate = true;
    }
  }
  return needsUpdate;
}

/**
 * Function that creates a new flow.
 * @param {String} flowName Name of the flow.
 * @param {String} flowPath Target path of the flow. 
 * @param {String} commands Commands to run.
 */
const createFlow = async (flowName, flowPath, commands) => {
  let scriptContent = "";
  let scriptFileExtension = "";
  const config = await loadConfig();

  const version = packageJson.version;
  const bashDisclosure =
    '# This script is generated by scriptflow-cli v:' + version + '\n\n';
  const batDisclosure =
    'REM This script is generated by scriptflow-cli v:' + version + ' \n\n####';
    const ps1Disclosure =
    '<#\n This script is generated by scriptflow-cli v:' + version + '\n #>';
  switch (config.terminalProfile) {
    case "bash":
      scriptContent = `#!/bin/bash\n\n${bashDisclosure}\n${commands.replaceAll(
        ",",
        '| tee -a /dev/tty | grep -q "Error" && exit 1 || exit 0\n\n'
      )}`;
      scriptFileExtension = ".sh";
      break;
    case "zsh":
      scriptContent = `#!/bin/zsh\n\n${bashDisclosure}\n${commands.replaceAll(
        ",",
        '| tee -a /dev/tty | grep -q "Error" && exit 1 || exit 0\n\n'
      )}`;
      scriptFileExtension = ".sh";
      break;
    case "powershell":
      // PowerShell script content
      scriptContent = `# PowerShell script content here\n\n${ps1Disclosure}\n${commands.replaceAll(
        ",",
        '| tee -a /dev/tty | grep -q "Error" && exit 1 || exit 0\n'
      )}`;
      scriptFileExtension = ".ps1";
      break;
    case "cmd":
      // CMD (batch script) content
      scriptContent = `@echo off\n\n${batDisclosure}\n${commands.replaceAll(
        ",",
        '| tee -a /dev/tty | grep -q "Error" && exit 1 || exit 0\n'
      )}`;
      scriptFileExtension = ".bat";
      break;
    default:
      console.log(prettify.formatError("Invalid terminal profile selected."));
      return;
  }
  const commandFolder = path.join(config.flowCommandDir, flowName);

  try {
    await fs.mkdir(commandFolder, { recursive: true });
    const scriptFile = path.join(commandFolder, `script${scriptFileExtension}`);
    await fs.writeFile(scriptFile, scriptContent);

    const flows = await loadFlows();
    flows.push({
      name: flowName,
      path: flowPath,
      script: scriptFile,
    });

    await saveFlows(flows);

    console.log(prettify.formatSuccess("Flow created successfully!"));
  } catch (error) {
    console.error(prettify.formatError("Error creating flow:"), error.message);
  }
};


/**
 * Function that prompts the user to create a new flow
 * @param {Boolean} tutorialRunning Checks if the tutorial is running, defaults to false
 */
const createFlowWithPrompt = async ({ tutorialRunning = false }) => {
  await checkForUpdates();

  const config = await loadConfig();

await checkInit();

  if (tutorialRunning) {
    console.log(prettify.formatAnnouncement(config.tutorial.steps[2].subSteps[0].output));
  }

  const questions = [
    {
      type: "input",
      name: "flowName",
      message: "Enter flow name:",
      validate: async (value) => {
        try {
          // check if flow name is valid (only alphanumeric, underscore, and dash allowed)
          if (/^([a-zA-Z0-9_-]*)$/.test(value) !== true) {
            return "Please enter a valid flow name";
          }
          //check if flow name already exists
          const flows = await loadFlows();
          const flow =
            flows !== null ? flows.find((f) => f.name === value) : null;
          if (flow) {
            return "Flow name already exists";
          }
          return true;
        } catch (error) {
          return "An Error Occurred: " + error.message;
        }
      },
    },
    {
      type: "input",
      name: "flowPath",
      message: "Enter the path where the flow will be called from:",
      default: path.join(process.cwd(), config.defaultFlowPath),
      validate: async (value) => {
        try {
          const stats = await fs.stat(value);
          return stats.isDirectory() || "Please enter a valid directory path";
        } catch (error) {
          return "Please enter a valid path";
        }
      },
    },
    {
      type: "input",
      name: "commands",
      message: tutorialRunning ? "Here We do a little scripting, input whatever you want or try 'echo \"Hello World!\", " : "Enter the commands to run (comma separated):",
      validate: async (value) => {
        try {
          if (value === "") {
            return "Please enter at least one command";
          }
          return true;
        } catch (error) {
          return "An Error Occurred: " + error.message;
        }
      },
    },
  ];

  const answers = await inquirer.prompt(questions);
  var { flowName, flowPath, commands } = answers;

  if (!commands.endsWith(",")) {
    commands += ",";
  }

  createFlow(flowName, flowPath, commands);

  if (tutorialRunning) {
    console.log(prettify.formatAnnouncement(config.tutorial.steps[2].subSteps[0].finished));
  }
};

/**
 * Function that deletes a flow
 * @param {String} flowName Name of the flow to be deleted
 */
const deleteFlow = async (flowName) => {
  await checkForUpdates();

  const config = await loadConfig();

await checkInit();

  const flows = await loadFlows();
  const flowIndex = flows.findIndex((f) => f.name === flowName);

  if (flowIndex === -1) {
    console.log("Flow not found");
    return;
  }

  const flow = flows[flowIndex];

  try {
    flows.splice(flowIndex, 1);
    await saveFlows(flows);
    await fs.rm(flow.script, { recursive: true });
    console.log("Flow deleted successfully!");
  } catch (error) {
    console.error("Error deleting flow:", error.message);
  }
};

/**
 * Function that initializes the flow manager
 */
const initialize = async () => {
  const config = await loadConfig();
  if (config.initialized) {
    console.log(prettify.formatInfo("Flow manager is already initialized!"));
  }

  var tutorialAnswer = false;

  console.log(prettify.formatAnnouncement(config.init_messages));
  if (!config.initialized) {
    tutorialAnswer = await inquirer.prompt({
      type: "confirm",
      name: "tutorial",
      message: config.tutorial.steps[0].message,
      default: true,
    });

    if (tutorialAnswer.tutorial) {
      console.clear();
      console.log(prettify.formatAnnouncement(config.tutorial.steps[1].message));
    }
  }

  await checkForUpdates();

  const terminalProfileAnswer = await inquirer.prompt({
    type: "list",
    name: "terminalProfile",
    message: "Select your terminal profile:",
    choices: ["bash", "zsh", "powershell", "cmd"],
    default: "bash",
  });

  const flowLocationAnswer = await inquirer.prompt({
    type: "input",
    name: "flowLocation",
    message: "Enter the path where flows will be stored:",
    default: config.flowDir.replace("$USER_HOME", os.homedir()),
  });

  config.terminalProfile = terminalProfileAnswer.terminalProfile;
  config.flowDir = flowLocationAnswer.flowLocation;
  config.flowCommandDir = path.join(config.flowDir, "commands");
  config.initialized = true;

  await saveConfig(config);
  console.log(prettify.formatSuccess("Flow manager initialized successfully!"));

  if (tutorialAnswer.tutorial) {
    console.clear();
    console.log(prettify.formatAnnouncement(config.tutorial.steps[2].message));
    createFlowWithPrompt({tutorialRunning:true});
  }
}


/**
 * Function that lists all flows available on the flow manager
 */
const listFlows = async () => {
  const config = await loadConfig();

await checkInit();

  const flows = await loadFlows();
  if (flows.length === 0) {
    console.log("No flows found.");
  } else {
    console.log("List of flows:");
    flows.forEach((flow) => {
      console.log(flow.name);
    });
  }
};


/**
 * Loads user configuration from the config.json file
 */
const loadConfig = async () => {
  try {
    const configData = await fs.readFile(configFile, "utf-8");
    return JSON.parse(configData);
  } catch (error) {
    throw new Error("Failed to load config.json: " + error.message);
  }
};

/**
 * Loads all flows from the flows.json file
 * @returns {Array} Array of flows
 */
const loadFlows = async () => {
  try {
    const config = await loadConfig();
    const flowsFile = path.join(config.flowDir, "flows.json");

    if (
      !(await fs
        .access(flowsFile)
        .then(() => true)
        .catch(() => false))
    ) {
      return [];
    }

    const flowsData = await fs.readFile(flowsFile, "utf-8");
    return JSON.parse(flowsData);
  } catch (error) {
    console.error("Error loading flows:", error.message);
    return [];
  }
};

/**
 * Function that opens a flow for editing through vs code and backups to default text openCommand if vs code cli is not installed.
 * @param {String} flowName Flow wanting to retrieve/edit. 
 */
const openFlowForEditing = async (flowName, openCommand = undefined, path = undefined) => {
  const config = await loadConfig();

await checkInit();

if(openCommand||path){
  // either openCommand or path is empty
  try{
  const validate = ((openCommand === undefined && path !== "") || (openCommand !== "" && path === undefined))
  if(!validate){
    throw new Error("Please provide either the openCommand or the path to the openCommand executable, but not both.")
  }

  if(openCommand !== undefined){
    config.defaultTextEditorCommand = openCommand;
    config.defaultTextEditorPath = null;
  }
  if(path !== undefined){
    config.defaultTextEditorCommand = null;
    config.defaultTextEditorPath = path;
  }

  await saveConfig(config);
 } catch (error) {
    console.error(prettify.formatError("Error opening flow for editing:"), error.message);
    return;
  }
}

  const flows = await loadFlows();
  const flow = flows.find((f) => f.name === flowName);

  if (!flow) {
    console.log("Flow not found");
    return;
  }

  const currentDir = process.cwd();
  process.chdir(flow.path);

  console.log("Opening flow for editing: " + flow.name);

  try {
    const { stdout, stderr } = await executeCommand(`${config.defaultTextEditor ?? config.defaultTextEditorPath} ${flow.script}`);

    if (stderr) {
      console.error(stderr);
    }
    console.log(stdout);
  } catch (error) {
    try {
      switch (config.terminalProfile) {
        case "bash":
        case "zsh":
          await executeCommand(`open ${flow.script}`);
          break;
        case "powershell":
        case "cmd":
          await executeCommand(`notepad ${flow.script}`);
          break;
      }
    } catch (error) {
      console.error("Error opening flow for editing:", error.message);
    }
  } finally {
    process.chdir(currentDir);
    console.log(prettify.formatSuccess("Finished."));
  }
};

/**
 * Function that re-initializes the flow manager
 */
const reinitialize = async () => {
  await checkForUpdates();

  // give user option to move flows to new location, or delete them, or cancel
  // if move, ask for new location
  // if delete, delete flows and ask for new location
  // if cancel, cancel

  const COMPLETED_MOVE = "Flows moved successfully!\n\nNew location:";
  const config = await loadConfig();

  //check if existing flows exist
  const flows = await loadFlows();
  if (flows.length > 0) {
    const verificationAnswer = await inquirer.prompt({
      type: "list",
      name: "verification",
      message:
        "You are about to reinitialize the flow manager. What would you like to do with existing flows?",
      choices: ["Move To New Location", "Delete Existing Flows", "Cancel"],
      default: "Move To New Location",
    });

    switch (verificationAnswer.verification) {
      case "Move To New Location":
        const newFlowLocationAnswer = await inquirer.prompt({
          type: "input",
          name: "flowLocation",
          message: "Enter the path where flows will be stored:",
          default: config.flowDir.replace("$USER_HOME", os.homedir()),
        });
        //move flow folder to new location recursively
        const execSync = require("child_process").execSync;
        switch (config.terminalProfile) {
          case "bash":
          case "zsh":
            execSync(
              `mv ${config.flowDir} ${newFlowLocationAnswer.flowLocation}; echo ${COMPLETED_MOVE}${newFlowLocationAnswer.flowLocation}`
            );
            break;
          case "powershell":
            execSync(
              `Move-Item -Path ${config.flowDir} -Destination ${newFlowLocationAnswer.flowLocation}; echo ${COMPLETED_MOVE}${newFlowLocationAnswer.flowLocation}`
            );
            break;
          case "cmd":
            execSync(
              `move ${config.flowDir} ${newFlowLocationAnswer.flowLocation}; echo ${COMPLETED_MOVE}${newFlowLocationAnswer.flowLocation}`
            );
            break;
          default:
            console.log("Invalid terminal profile selected.");
        }
        //update config
        config.flowDir = newFlowLocationAnswer.flowLocation;
        config.flowCommandDir = path.join(config.flowDir, "commands");
        config.initialized = true;
        await saveConfig(config);
        break;
      case "Delete Existing Flows":
        //delete flows folder
        const exec = require("child_process").exec;

        switch (config.terminalProfile) {
          case "bash":
          case "zsh":
            exec(`rm -rf ${config.flowDir}`);
            break;
          case "powershell":
            exec(`Remove-Item -Recurse -Force ${config.flowDir}`);
            break;
          case "cmd":
            exec(`rmdir /s /q ${config.flowDir}`);
            break;
          default:
            console.log("Invalid terminal profile selected.");
            return;
        }

        //update config
        config.initialized = false;
        await saveConfig(config);

        //reinitialize
        await initialize();
        break;
      case "Cancel":
        return;
    }
  }
};

/**
 * Function that resets the flow manager config
 */
const resetConfig = async () => {
  const config = await loadConfig();
  config.flowDir = path.join(os.homedir(), ".flow");
  config.flowCommandDir = path.join(config.flowDir, "commands");
  config.terminalProfile = "bash";
  config.defaultFlowPath = ".";
  config.initialized = false;
  await saveConfig(config);
};

/**
 * Function that runs a flow
 * @param {String} flowName Name of the flow to be run
 */
const runFlow = async (flowName) => {
  await checkForUpdates();

  const flows = await loadFlows();
  var flow = flows.find((f) => f.name === flowName);

  if(!flow) {
    console.log(prettify.formatError("Flow not found"));
    return;
  }

  await checkScriptForVersion(flow.script).then(
    async (result) => {
      if (result) {
        const scriptFile = flow.script;
        try {
          var scriptContent = await fs.readFile(scriptFile, "utf-8");
          // Update from v0.0.3 to v0.0.4
          //replace shebang with blank
          scriptContent = scriptContent.replace("#.*\n\n", "");
          if (
            !scriptContent.includes(
              '| tee -a /dev/tty | grep -q "Error" && exit 1 || exit 0\n\n'
            )
          ) {
            // replace '\n\n' with ','
            scriptContent = scriptContent.replaceAll("\n\n", ",");
            if (!scriptContent.endsWith(",")) {
              scriptContent += ",";
            }
            await createFlow(flow.name, flow.path, scriptContent);
            console.log("Flow updated successfully!");
          }
        } catch (error) {
          console.error("Error updating flow:", error.message);
        }
      }
    }
  );



  const config = await loadConfig();

await checkInit();

  if (!flow) {
    console.log("Flow not found");
    return;
  }

  const currentDir = process.cwd();
  process.chdir(flow.path);

  console.log("Running flow: " + flow.name);

  var shellRunner;
  switch (config.terminalProfile) {
    case "bash":
    case "zsh":
      shellRunner = "sh";
      break;
    case "powershell":
      shellRunner = "";
      break;
    case "cmd":
      shellRunner = "cmd";
      break;
    default:
      console.log("Invalid terminal profile selected.");
      return;
  }

  try {
    const { stdout, stderr } = await executeCommand(
      `${shellRunner} ${flow.script}`
    );
    console.log(stdout);
    if (stderr) {
      console.error(stderr);
    }
  } catch (error) {
    console.error("Error running flow:", error.message);
  } finally {
    process.chdir(currentDir);
    console.log("Finished.");
  }
};

/**
 * Function that saves the user configuration to the config.json file
 * @param {Object} config Configuration object to be saved
 */
const saveConfig = async (config) => {
  await checkForUpdates();

  try {
    await fs.writeFile(configFile, JSON.stringify(config, null, 2));
  } catch (error) {
    throw new Error("Failed to save config.json: " + error.message);
  }
};

/**
 * Function that saves the flows to the flows.json file
 * @param {Array} flows Array of flows to be saved
 */
const saveFlows = async (flows) => {
  const config = await loadConfig();
  const flowsFile = path.join(config.flowDir, "flows.json");

  try {
    await fs.writeFile(flowsFile, JSON.stringify(flows, null, 2));
  } catch (error) {
    console.error("Error saving flows:", error.message);
  }
};


/**
 * Function that updates the flow manager
 */
const update = async () => {
  //get current config
  const config = await loadConfig();

  //update scriptflow-cli
  const { stdout, stderr } = await executeCommand(
    'npm i -g scriptflow-cli | grep -q "Error" && exit 1 || exit 0'
  );
  console.log(stdout);
  if (stderr) {
    console.error(stderr);
  }

  // get flows and update them
  const flows = await loadFlows();
  for (const flow of flows) {
    const scriptFile = flow.script;
    var scriptContent = await fs.readFile(scriptFile, "utf-8");
    // Update from v0.0.3 to v1.0.0
    //replace shebang with blank
    scriptContent = scriptContent.replace("#.*\n\n", "");
    //replace shebang and disclosure with blank
    scriptContent = scriptContent.replace("#.*\n\n.*\n\n####", "");
    if (
      !scriptContent.includes(
        '| tee -a /dev/tty | grep -q "Error" && exit 1 || exit 0\n\n'
      )
    ) {
      // replace '\n\n' with ','
      scriptContent = scriptContent.replaceAll("\n\n", ",");
      if (!scriptContent.endsWith(",")) {
        scriptContent += ",";
      } else {
        continue;
      }
      createFlow(flow.name, flow.path, scriptContent);
    }

    saveConfig(config);
    // log success and any breaking changes needed to be made.
    console.log("Flow manager updated successfully!");
    console.log(
      "Please check for any breaking changes in the latest version and update your flows accordingly.:\nhttps://github.com/ScriptFlow/scriptflow-cli/releases"
    );
  }
};

/**
 * Developer function that views the flow manager config
 */
const viewConfig = async () => {
  const config = await loadConfig();
  console.log(config);
};

/**
 * Command Manager for the scriptflow-cli
 */
yargs(hideBin(process.argv))
  .command("init", "Initialize the flow manager", {}, initialize)
  .command("create", "Create a new flow", {}, createFlowWithPrompt)
  .command("list", "List all flows", {}, listFlows)
  .command("run <flowName>", "Run a flow by name", {}, (flow) =>
    runFlow(flow.flowName)
  )
  .command("delete <flowName>", "Delete a flow by name", {}, (flow) =>
    deleteFlow(flow.flowName)
  )
  .command("reinit", "Reinitialize the flow manager", {}, reinitialize)
  .command("edit <flowName>", "Open a flow for editing\n" + prettify.formatInfo("--openCommand, --o") + " Change default editor command\n" + prettify.formatInfo("--path, -p") +" Change default text editor path\n\n", (yargs) => {
    yargs.positional("flowName", {
      alias: "f",
      type: "string",
      describe: "The name of the flow to open for editing",
    })
    .positional("openCommand", {
      alias: "o",
      type: "string",
      describe: "The name of the editor to use"
    })
    .positional("path", {
      alias: "p",
      type: "string",
      describe: "The path of the editor executable to open for editing"
    })
  }, (flow) =>
    openFlowForEditing(flow.flowName)
  )
  .command("default", "Reset the flow manager config", {}, resetConfig)
  .command("config", "View the flow manager config", {}, viewConfig)
  .command("update", "Update the flow manager", {}, update)
  .command("clear", "Clear all flows", {}, clear)
  .command("news", "View announcements\n" + prettify.formatInfo("--versionChoice, -v") +" choose version\n\n", (yargs) => {
    yargs.positional('versionChoice', {
      type: 'string',
      default: 'LIST',
      describe: 'The version of the announcements you would like to view. Type "LIST" to view all versions available.'
    })
  }, ({versionChoice}) => announcements({versionChoice:versionChoice}))
  .demandCommand()
  .help().argv;